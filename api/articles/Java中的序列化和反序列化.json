{"title":"Java中的序列化和反序列化","uid":"1150b55b0c19da05733ad0e6d11f2075","slug":"Java中的序列化和反序列化","date":"2023-04-21T16:29:49.000Z","updated":"2023-04-27T09:40:34.038Z","comments":true,"path":"api/articles/Java中的序列化和反序列化.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/03/14/006c1f400197c149.webp","content":"<h1 id=\"Serializable接口和ObjectInputStream-x2F-ObjectOutputStream类\"><a href=\"#Serializable接口和ObjectInputStream-x2F-ObjectOutputStream类\" class=\"headerlink\" title=\"Serializable接口和ObjectInputStream&#x2F;ObjectOutputStream类\"></a>Serializable接口和ObjectInputStream&#x2F;ObjectOutputStream类</h1><p>Serializable接口和ObjectInputStream&#x2F;ObjectOutputStream类是Java中最常用的序列化和反序列化方案。下面是一个示例代码，演示如何对一个对象进行序列化和反序列化：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.io.*;\n\npublic class SerializationDemo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个Person对象\n        Person person &#x3D; new Person(&quot;Alice&quot;, 25);\n\n        &#x2F;&#x2F; 序列化对象到文件\n        try &#123;\n            FileOutputStream fileOut &#x3D; new FileOutputStream(&quot;person.ser&quot;);\n            ObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut);\n            out.writeObject(person);\n            out.close();\n            fileOut.close();\n            System.out.println(&quot;Serialized data is saved in person.ser&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        &#x2F;&#x2F; 从文件中反序列化对象\n        try &#123;\n            FileInputStream fileIn &#x3D; new FileInputStream(&quot;person.ser&quot;);\n            ObjectInputStream in &#x3D; new ObjectInputStream(fileIn);\n            Person deserializedPerson &#x3D; (Person) in.readObject();\n            in.close();\n            fileIn.close();\n            System.out.println(&quot;Deserialized data:&quot;);\n            System.out.println(&quot;Name: &quot; + deserializedPerson.getName());\n            System.out.println(&quot;Age: &quot; + deserializedPerson.getAge());\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nclass Person implements Serializable &#123;\n    private static final long serialVersionUID &#x3D; 1L;\n    private String name;\n    private int age;\n\n    public Person(String name, int age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例代码中，我们创建了一个名为Person的类，并将其实现了Serializable接口。这个类包含了一个字符串类型的name和一个整数类型的age。在主函数中，我们首先创建了一个Person对象，并将其序列化到一个名为person.ser的文件中。接着我们从该文件中反序列化对象，并打印出反序列化后的对象的name和age属性。</p>\n<p>需要注意的是，为了实现序列化和反序列化，我们需要将要序列化的类实现Serializable接口。此外，还需要在类中声明一个名为serialVersionUID的静态常量。这个常量用于指定序列化版本号，确保在反序列化过程中使用的是同一个版本的类。</p>\n<h2 id=\"serialVersionUID的作用\"><a href=\"#serialVersionUID的作用\" class=\"headerlink\" title=\"serialVersionUID的作用\"></a>serialVersionUID的作用</h2><p>一句话：其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</p>\n<p>serialVersionUID有两种显示的生成方式：</p>\n<ul>\n<li>一是默认的1L，比如：private static final long serialVersionUID &#x3D; 1L;</li>\n<li>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段;</li>\n</ul>\n<h1 id=\"JSON序列化\"><a href=\"#JSON序列化\" class=\"headerlink\" title=\"JSON序列化\"></a>JSON序列化</h1><p>JSON是一种轻量级的数据交换格式，可以将对象转换为JSON格式的字符串进行存储和传输。Java中可以使用许多第三方库（如Jackson、Gson等）来实现JSON序列化和反序列化。下面是一个使用Fastjson2进行JSON序列化和反序列化的示例代码：</p>\n<h2 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.alibaba.fastjson.JSON;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SerializationDemo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个List对象\n        List&lt;Person&gt; personList &#x3D; new ArrayList&lt;&gt;();\n        personList.add(new Person(&quot;Alice&quot;, 25));\n        personList.add(new Person(&quot;Bob&quot;, 30));\n\n        &#x2F;&#x2F; 序列化List对象为JSON字符串\n        String jsonString &#x3D; JSON.toJSONString(personList);\n        System.out.println(&quot;Serialized data:&quot;);\n        System.out.println(jsonString);\n    &#125;\n&#125;\n\nclass Person &#123;\n    private String name;\n    private int age;\n\n    public Person(String name, int age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.alibaba.fastjson.JSON;\nimport java.util.List;\n\npublic class DeserializationDemo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; JSON字符串\n        String jsonString &#x3D; &quot;[&#123;\\&quot;age\\&quot;:25,\\&quot;name\\&quot;:\\&quot;Alice\\&quot;&#125;,&#123;\\&quot;age\\&quot;:30,\\&quot;name\\&quot;:\\&quot;Bob\\&quot;&#125;]&quot;;\n\n        &#x2F;&#x2F; 反序列化JSON字符串为List&lt;Person&gt;对象\n        List&lt;Person&gt; personList &#x3D; JSON.parseArray(jsonString, Person.class);\n        System.out.println(&quot;Deserialized data:&quot;);\n        for (Person person : personList) &#123;\n            System.out.println(&quot;Name: &quot; + person.getName());\n            System.out.println(&quot;Age: &quot; + person.getAge());\n        &#125;\n    &#125;\n&#125;\n\nclass Person &#123;\n    private String name;\n    private int age;\n\n    public Person() &#123;&#125;\n\n    public Person(String name, int age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n&#125;</code></pre>\n\n<p>需要注意的是，在反序列化过程中，fastjson需要知道要反序列化的目标类型，因此需要将目标类型作为第二个参数传递给parseArray()方法。在上面的示例代码中，我们将Person.class作为目标类型传递给parseArray()方法。</p>\n<p>总的来说，使用fastjson2进行Java对象的序列化和反序列化非常简单，只需要调用toJSONString()和parseArray()方法即可。需要注意的是，在使用fastjson2进行反序列化时，需要指定目标类型。</p>\n","feature":true,"text":"Serializable接口和ObjectInputStream&#x2F;ObjectOutputStream类Serializable接口和ObjectInputStream&#x2F;ObjectOutputStream类是Java中最常用的序列化和反序列化方案。下面是一个...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"Java后端","slug":"Java后端","count":5,"path":"api/categories/Java后端.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Serializable%E6%8E%A5%E5%8F%A3%E5%92%8CObjectInputStream-x2F-ObjectOutputStream%E7%B1%BB\"><span class=\"toc-text\">Serializable接口和ObjectInputStream&#x2F;ObjectOutputStream类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#serialVersionUID%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">serialVersionUID的作用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JSON%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">JSON序列化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">序列化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">反序列化</span></a></li></ol></li></ol>","author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM内存管理","uid":"e1a635b0a39e4c098d3b64531c744865","slug":"JVM内存管理","date":"2023-05-09T03:20:33.000Z","updated":"2023-05-09T06:09:22.296Z","comments":true,"path":"api/articles/JVM内存管理.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/04/18/24189eeb829832cd.webp","text":"JVM内存管理JVM的内存模型JVM的内存模型是Java程序运行时所使用的内存的抽象，它定义了Java程序中各种数据的存储方式和访问方式，以及垃圾回收器的行为等相关规则。了解JVM的内存模型对于Java程序的开发、调试和性能优化都是非常重要的。 JVM的内存区域JVM的内存区域可...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"JVM","slug":"JVM","count":3,"path":"api/categories/JVM.json"}],"tags":[{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"}],"author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2023-04-18T15:48:52.000Z","updated":"2023-04-18T15:51:00.870Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/04/18/24189eeb829832cd.webp","text":"JVM：Java虚拟机Java虚拟机（Java Virtual Machine，JVM）是Java语言的核心，可以在不同的计算机上运行Java程序，实现Java语言的“一次编写，到处运行”的特性。本文将介绍JVM的核心原理和一些常用的调优技巧。 JVM的核心原理JVM是由Java...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"JVM","slug":"JVM","count":3,"path":"api/categories/JVM.json"}],"tags":[{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"}],"author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}}}}