{"title":"Redisson分布式锁原理","uid":"ccf7352a57f14a8bc052972b9b2f87e5","slug":"Redisson分布式锁原理","date":"2023-04-08T16:50:57.000Z","updated":"2023-04-12T07:16:26.847Z","comments":true,"path":"api/articles/Redisson分布式锁原理.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/04/09/b6cb052c62216566.png","content":"<h1 id=\"Redisson实现分布式锁\"><a href=\"#Redisson实现分布式锁\" class=\"headerlink\" title=\"Redisson实现分布式锁\"></a>Redisson实现分布式锁</h1><h2 id=\"一、高效分布式锁\"><a href=\"#一、高效分布式锁\" class=\"headerlink\" title=\"一、高效分布式锁\"></a>一、高效分布式锁</h2><h3 id=\"1-互斥\"><a href=\"#1-互斥\" class=\"headerlink\" title=\"1.互斥\"></a>1.互斥</h3><p>在分布式高并发的条件下，最需要保证同一时刻只能有一个线程获得锁，这是最基本的一点。</p>\n<h3 id=\"2-防止死锁\"><a href=\"#2-防止死锁\" class=\"headerlink\" title=\"2.防止死锁\"></a>2.防止死锁</h3><p>在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令,导致其它线程都无法获得锁，造成死锁。</p>\n<p>所以分布式非常有必要设置锁的<strong>有效时间</strong>，确保系统出现故障后，在一定时间内能够主动去释放锁，避免造成死锁的情况。</p>\n<h3 id=\"3、性能\"><a href=\"#3、性能\" class=\"headerlink\" title=\"3、性能\"></a>3、性能</h3><p>对于访问量大的共享资源，需要考虑减少锁等待的时间，避免导致大量线程阻塞。</p>\n<p>所以在锁的设计时，需要考虑两点。</p>\n<p>1、<strong>锁的颗粒度要尽量小。</strong>比如你要通过锁来减库存，那这个锁的名称你可以设置成是商品的ID，而不是任取名称。这样这个锁只对当前商品有效,锁的颗粒度小。</p>\n<p>2、<strong>锁的范围尽量要小。</strong>比如只要锁2行代码就可以解决问题的，那就不要去锁10行代码了。</p>\n<h3 id=\"4、重入\"><a href=\"#4、重入\" class=\"headerlink\" title=\"4、重入\"></a>4、重入</h3><p>我们知道ReentrantLock是可重入锁，那它的特点就是：同一个线程可以重复拿到同一个资源的锁。<strong>重入锁非常有利于资源的高效利用。</strong></p>\n<h2 id=\"二、分布式锁需满足四个条件\"><a href=\"#二、分布式锁需满足四个条件\" class=\"headerlink\" title=\"二、分布式锁需满足四个条件\"></a>二、分布式锁需满足四个条件</h2><p>为了确保分布式锁可用，至少要确保锁的实现同时满足以下四个条件：</p>\n<ol>\n<li><strong>互斥性。</strong>在任意时刻，只有一个客户端能持有锁。</li>\n<li><strong>不会发生死锁。</strong>即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>\n<li><strong>解铃还须系铃人。</strong>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。</li>\n<li><strong>具有容错性。</strong>只要大多数Redis节点正常运行，客户端就能够获取和释放锁。</li>\n</ol>\n<h2 id=\"三、Redisson原理分析\"><a href=\"#三、Redisson原理分析\" class=\"headerlink\" title=\"三、Redisson原理分析\"></a>三、Redisson原理分析</h2><p><img src=\"https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190618183025891-1248337684.jpg\" alt=\"img\"></p>\n<h3 id=\"1、加锁机制\"><a href=\"#1、加锁机制\" class=\"headerlink\" title=\"1、加锁机制\"></a>1、加锁机制</h3><p>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。</p>\n<p>线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。</p>\n<h3 id=\"2、watch-dog自动延期机制\"><a href=\"#2、watch-dog自动延期机制\" class=\"headerlink\" title=\"2、watch dog自动延期机制\"></a>2、watch dog自动延期机制</h3><p>在一个分布式环境下，假如一个线程获得锁后，突然服务器宕机了，那么这个时候在一定时间后这个锁会自动释放，你也可以设置锁的有效时间(不设置默认30秒），这样的目的主要是防止死锁的发生。</p>\n<p>但在实际开发中会有下面一种情况:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\t&#x2F;&#x2F;设置锁1秒过去\n  redissonLock.lock(&quot;redisson&quot;, 1);\n  &#x2F;**\n   * 业务逻辑需要咨询2秒\n   *&#x2F;\n  redissonLock.release(&quot;redisson&quot;);\n&#x2F;**\n * 线程1 进来获得锁后，线程一切正常并没有宕机，但它的业务逻辑需要执行2秒，这就会有个问题，在 线程1 执行1秒后，这个锁就自动过期了，\n * 那么这个时候 线程2 进来了。那么就存在 线程1和线程2 同时在这段业务逻辑里执行代码，这当然是不合理的。\n * 而且如果是这种情况，那么在解锁时系统会抛异常，因为解锁和加锁已经不是同一线程了，具体后面代码演示。\n *&#x2F;</code></pre>\n\n<p>所以这个时候<strong>看门狗</strong>就出现了，它的作用就是 线程1 业务还没有执行完，时间就过了，线程1 还想持有锁的话，就会启动一个watch dog<strong>后台线程，不断的延长锁key的生存时间。</strong></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>正常这个看门狗线程是不启动的，还有就是这个看门狗启动后对整体性能也会有一定影响，所以不建议开启看门狗。</p>\n\n</div>\n<h3 id=\"3、为啥要用lua脚本呢？\"><a href=\"#3、为啥要用lua脚本呢？\" class=\"headerlink\" title=\"3、为啥要用lua脚本呢？\"></a>3、为啥要用lua脚本呢？</h3><p>主要是如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的<strong>原子性</strong>。</p>\n<h3 id=\"4、可重入加锁机制\"><a href=\"#4、可重入加锁机制\" class=\"headerlink\" title=\"4、可重入加锁机制\"></a>4、可重入加锁机制</h3><p>Redisson可以实现可重入加锁机制的原因，跟两点有关：</p>\n<p>1、Redis存储锁的数据类型是 Hash类型。</p>\n<p>2、Hash数据类型的key值包含了当前线程信息。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190618183046827-1994396879.png\" alt=\"img\"></p>\n<p><strong>它最大的优点就是相同线程不需要在等待锁，而是可以直接进行相应操作。</strong></p>\n<h3 id=\"5、Redis分布式锁的缺点\"><a href=\"#5、Redis分布式锁的缺点\" class=\"headerlink\" title=\"5、Redis分布式锁的缺点\"></a>5、Redis分布式锁的缺点</h3><p>Redis分布式锁会有个缺陷，就是在Redis哨兵模式下:</p>\n<p><strong>客户端1</strong> 对某个<strong>master节点</strong>写入了redisson锁，此时会异步复制给对应的 slave节点。但是这个过程中一旦发生 master节点宕机，主备切换，slave节点从变为了 master节点。</p>\n<p>这时<strong>客户端2</strong>来尝试加锁的时候，在新的master节点上也能加锁，此时就会导致多个客户端对同一个分布式锁完成了加锁。</p>\n<p>这时系统在业务语义上一定会出现问题，<strong>导致各种脏数据的产生</strong>。</p>\n<p><strong>缺陷：</strong>在哨兵模式或者主从模式下，如果 master实例宕机的时候，可能导致多个客户端同时完成加锁。</p>\n","text":"Redisson实现分布式锁一、高效分布式锁1.互斥在分布式高并发的条件下，最需要保证同一时刻只能有一个线程获得锁，这是最基本的一点。 2.防止死锁在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令,导致其它...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"源码","slug":"源码","count":2,"path":"api/categories/源码.json"}],"tags":[{"name":"Redisson","slug":"Redisson","count":1,"path":"api/tags/Redisson.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">Redisson实现分布式锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E9%AB%98%E6%95%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">一、高效分布式锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BA%92%E6%96%A5\"><span class=\"toc-text\">1.互斥</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%98%B2%E6%AD%A2%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">2.防止死锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">3、性能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%87%8D%E5%85%A5\"><span class=\"toc-text\">4、重入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%9C%80%E6%BB%A1%E8%B6%B3%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">二、分布式锁需满足四个条件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Redisson%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\"><span class=\"toc-text\">三、Redisson原理分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1、加锁机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81watch-dog%E8%87%AA%E5%8A%A8%E5%BB%B6%E6%9C%9F%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2、watch dog自动延期机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E4%B8%BA%E5%95%A5%E8%A6%81%E7%94%A8lua%E8%84%9A%E6%9C%AC%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">3、为啥要用lua脚本呢？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">4、可重入加锁机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%E3%80%81Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">5、Redis分布式锁的缺点</span></a></li></ol></li></ol></li></ol>","author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis分布式锁","uid":"e16a4a23331e888e1fd9d32099166ee5","slug":"Redis分布式锁","date":"2023-04-12T07:15:05.000Z","updated":"2023-04-12T07:19:40.965Z","comments":true,"path":"api/articles/Redis分布式锁.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/03/14/4cf2b42b97602a2b.webp","text":"Redis分布式锁前言在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。 随着技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"源码","slug":"源码","count":2,"path":"api/categories/源码.json"}],"tags":[{"name":"分布式锁","slug":"分布式锁","count":1,"path":"api/tags/分布式锁.json"}],"author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"VuePress快速入门指南","uid":"dd0b7c5b4d17cac6f57efc04d54ade04","slug":"VuePress快速入门指南","date":"2023-04-04T16:59:28.000Z","updated":"2023-04-04T17:05:58.428Z","comments":true,"path":"api/articles/VuePress快速入门指南.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/04/05/f2f9398b1bbec2e0.webp","text":"VuePress快速入门使用指南VuePress是一个基于Vue.js的静态网站生成器，它可以帮助你快速搭建一个静态网站，并且可以方便地进行文档编写和发布。本文将介绍VuePress的基本使用方法，帮助你快速入门。 安装VuePress安装VuePress需要先安装Node.js...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"快速入门使用指南","slug":"快速入门使用指南","count":1,"path":"api/categories/快速入门使用指南.json"}],"tags":[{"name":"博客框架","slug":"博客框架","count":1,"path":"api/tags/博客框架.json"}],"author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}}}}