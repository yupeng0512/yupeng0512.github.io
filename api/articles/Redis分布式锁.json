{"title":"Redis分布式锁","uid":"e16a4a23331e888e1fd9d32099166ee5","slug":"Redis分布式锁","date":"2023-04-12T07:15:05.000Z","updated":"2023-04-12T07:19:40.965Z","comments":true,"path":"api/articles/Redis分布式锁.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/03/14/4cf2b42b97602a2b.webp","content":"<h1 id=\"Redis分布式锁\"><a href=\"#Redis分布式锁\" class=\"headerlink\" title=\"Redis分布式锁\"></a>Redis分布式锁</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。</p>\n<p>随着技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，即保证某一方法同一时刻只能被一个线程执行。在单机环境中，应用是在同一进程下的，只需要保证单进程多线程环境中的线程安全性，通过 JAVA 提供的 volatile、ReentrantLock、synchronized 以及 concurrent 并发包下一些线程安全的类等就可以做到。而在多机部署环境中，不同机器不同进程，就需要在多进程下保证线程的安全性了。因此，分布式锁应运而生。</p>\n<h2 id=\"常见分布式锁方案对比\"><a href=\"#常见分布式锁方案对比\" class=\"headerlink\" title=\"常见分布式锁方案对比\"></a>常见分布式锁方案对比</h2><table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"center\">方案</th>\n<th align=\"center\">实现原理</th>\n<th align=\"center\">优点</th>\n<th align=\"center\">缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">基于数据库的分布式锁</td>\n<td align=\"center\">使用关系型数据库</td>\n<td align=\"center\">利用数据库的行锁或表锁进行加锁和解锁</td>\n<td align=\"center\">简单易用，适用于小型项目；依赖数据库，易于理解和实现</td>\n<td align=\"center\">性能较低；某些数据库可能无法支持；可能引起死锁</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">使用NoSQL数据库</td>\n<td align=\"center\">利用NoSQL数据库原子性操作进行加锁和解锁</td>\n<td align=\"center\">性能较高，可扩展性好</td>\n<td align=\"center\">依赖于特定的NoSQL数据库实现</td>\n</tr>\n<tr>\n<td align=\"center\">基于缓存的分布式锁</td>\n<td align=\"center\">使用Redis</td>\n<td align=\"center\">利用Redis的<code>SETNX</code>等原子操作进行加锁和解锁</td>\n<td align=\"center\">性能高，可扩展性好；适用于高并发场景</td>\n<td align=\"center\">依赖Redis；加锁和解锁操作不是原子操作，可能导致锁泄露</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">使用Memcached</td>\n<td align=\"center\">利用Memcached的原子操作进行加锁和解锁</td>\n<td align=\"center\">性能高，可扩展性好；适用于高并发场景</td>\n<td align=\"center\">依赖Memcached；加锁和解锁操作不是原子操作，可能导致锁泄露</td>\n</tr>\n<tr>\n<td align=\"center\">基于Zookeeper的分布式锁</td>\n<td align=\"center\">使用Apache Zookeeper</td>\n<td align=\"center\">利用Zookeeper的临时顺序节点进行加锁和解锁</td>\n<td align=\"center\">高可靠性，强一致性；适用于高可用场景</td>\n<td align=\"center\">性能较低；依赖Zookeeper</td>\n</tr>\n<tr>\n<td align=\"center\">基于分布式协调服务的分布式锁</td>\n<td align=\"center\">使用etcd</td>\n<td align=\"center\">利用etcd的分布式键值存储进行加锁和解锁</td>\n<td align=\"center\">高可靠性，强一致性；适用于高可用场景</td>\n<td align=\"center\">性能较低；依赖etcd</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">使用Consul</td>\n<td align=\"center\">利用Consul的分布式键值存储进行加锁和解锁</td>\n<td align=\"center\">高可靠性，强一致性；适用于高可用场景</td>\n<td align=\"center\">性能较低；依赖Consul</td>\n</tr>\n</tbody></table>\n<p>选择适合的分布式锁方案时，需要根据项目的具体需求和场景进行权衡。例如，对于高并发场景，可以选择基于缓存的分布式锁；而对于高可用场景，可以选择基于Zookeeper或分布式协调服务的分布式锁。</p>\n","text":"Redis分布式锁前言在某些场景中，多个进程必须以互斥的方式独占共享资源，这时用分布式锁是最直接有效的。 随着技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，为了保证数据不重复，要求在同一时刻，同一任务只在一个节点上运行，...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"源码","slug":"源码","count":2,"path":"api/categories/源码.json"}],"tags":[{"name":"分布式锁","slug":"分布式锁","count":1,"path":"api/tags/分布式锁.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">Redis分布式锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">常见分布式锁方案对比</span></a></li></ol></li></ol>","author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Spring MVC工作流程","uid":"ade989371093aa8d60f14a637377697c","slug":"Spring-MVC工作流程","date":"2023-04-18T12:24:31.000Z","updated":"2023-04-18T13:12:19.480Z","comments":true,"path":"api/articles/Spring-MVC工作流程.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/03/14/562384a91e30dfe8.jpg","text":"Spring MVC的工作原理Spring MVC是一个基于Java的Web框架，它遵循MVC（Model-View-Controller）模式来组织应用程序的代码结构。MVC模式将应用程序分为三个部分：模型（Model）、视图（View）和控制器（Controller）。其中，...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"Spring","slug":"Spring","count":1,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","count":1,"path":"api/tags/Spring-MVC.json"}],"author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redisson分布式锁原理","uid":"ccf7352a57f14a8bc052972b9b2f87e5","slug":"Redisson分布式锁原理","date":"2023-04-08T16:50:57.000Z","updated":"2023-04-12T07:16:26.847Z","comments":true,"path":"api/articles/Redisson分布式锁原理.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2023/04/09/b6cb052c62216566.png","text":"Redisson实现分布式锁一、高效分布式锁1.互斥在分布式高并发的条件下，最需要保证同一时刻只能有一个线程获得锁，这是最基本的一点。 2.防止死锁在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令,导致其它...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"源码","slug":"源码","count":2,"path":"api/categories/源码.json"}],"tags":[{"name":"Redisson","slug":"Redisson","count":1,"path":"api/tags/Redisson.json"}],"author":{"name":"啡鹏","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2023/03/14/b9c0245a1e08709e.webp","link":"/","description":"一个跑马拉松的程序员","socials":{"github":"https://github.com/yupeng0512/yupeng0512.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/zuo-ye-chen-guang","csdn":"","juejin":"","customs":{}}}}}